"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Cosmos SDK - Legacy REST and gRPC Gateway docs
 * A REST interface for state queries, legacy transactions
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryApiFp = exports.QueryApiAxiosParamCreator = exports.MintApi = exports.MintApiFactory = exports.MintApiFp = exports.MintApiAxiosParamCreator = exports.GovernanceApi = exports.GovernanceApiFactory = exports.GovernanceApiFp = exports.GovernanceApiAxiosParamCreator = exports.GaiaRESTApi = exports.GaiaRESTApiFactory = exports.GaiaRESTApiFp = exports.GaiaRESTApiAxiosParamCreator = exports.DistributionApi = exports.DistributionApiFactory = exports.DistributionApiFp = exports.DistributionApiAxiosParamCreator = exports.BankApi = exports.BankApiFactory = exports.BankApiFp = exports.BankApiAxiosParamCreator = exports.AuthApi = exports.AuthApiFactory = exports.AuthApiFp = exports.AuthApiAxiosParamCreator = exports.TendermintTypesVoteTypeEnum = exports.TendermintTypesSignedMsgType = exports.TendermintTypesCommitSigBlockIdFlagEnum = exports.TendermintTypesBlockIDFlag = exports.SingleRepresentsASingleSignerModeEnum = exports.InlineResponse20066ValidatorsStatusEnum = exports.InlineResponse20057VotesOptionEnum = exports.InlineResponse20057OptionsOptionEnum = exports.InlineResponse20052ProposalsStatusEnum = exports.InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum = exports.InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum = exports.InlineObject16ModeEnum = exports.CosmosTxV1beta1OrderBy = exports.CosmosTxV1beta1ModeInfoSingleModeEnum = exports.CosmosTxV1beta1BroadcastTxRequestModeEnum = exports.CosmosTxV1beta1BroadcastMode = exports.CosmosTxSigningV1beta1SignMode = exports.CosmosStakingV1beta1ValidatorStatusEnum = exports.CosmosStakingV1beta1BondStatus = exports.CosmosGovV1beta1WeightedVoteOptionOptionEnum = exports.CosmosGovV1beta1VoteOption = exports.CosmosGovV1beta1VoteOptionEnum = exports.CosmosGovV1beta1ProposalStatus = exports.CosmosGovV1beta1ProposalStatusEnum = void 0;
exports.TransactionsApi = exports.TransactionsApiFactory = exports.TransactionsApiFp = exports.TransactionsApiAxiosParamCreator = exports.TendermintRPCApi = exports.TendermintRPCApiFactory = exports.TendermintRPCApiFp = exports.TendermintRPCApiAxiosParamCreator = exports.StakingApi = exports.StakingApiFactory = exports.StakingApiFp = exports.StakingApiAxiosParamCreator = exports.SlashingApi = exports.SlashingApiFactory = exports.SlashingApiFp = exports.SlashingApiAxiosParamCreator = exports.ServiceApi = exports.ServiceApiFactory = exports.ServiceApiFp = exports.ServiceApiAxiosParamCreator = exports.QueryApi = exports.QueryApiFactory = void 0;
var axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
var base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var CosmosGovV1beta1ProposalStatusEnum;
(function (CosmosGovV1beta1ProposalStatusEnum) {
    CosmosGovV1beta1ProposalStatusEnum["Unspecified"] = "PROPOSAL_STATUS_UNSPECIFIED";
    CosmosGovV1beta1ProposalStatusEnum["DepositPeriod"] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
    CosmosGovV1beta1ProposalStatusEnum["VotingPeriod"] = "PROPOSAL_STATUS_VOTING_PERIOD";
    CosmosGovV1beta1ProposalStatusEnum["Passed"] = "PROPOSAL_STATUS_PASSED";
    CosmosGovV1beta1ProposalStatusEnum["Rejected"] = "PROPOSAL_STATUS_REJECTED";
    CosmosGovV1beta1ProposalStatusEnum["Failed"] = "PROPOSAL_STATUS_FAILED";
})(CosmosGovV1beta1ProposalStatusEnum = exports.CosmosGovV1beta1ProposalStatusEnum || (exports.CosmosGovV1beta1ProposalStatusEnum = {}));
/**
 * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
 * @export
 * @enum {string}
 */
var CosmosGovV1beta1ProposalStatus;
(function (CosmosGovV1beta1ProposalStatus) {
    CosmosGovV1beta1ProposalStatus["Unspecified"] = "PROPOSAL_STATUS_UNSPECIFIED";
    CosmosGovV1beta1ProposalStatus["DepositPeriod"] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
    CosmosGovV1beta1ProposalStatus["VotingPeriod"] = "PROPOSAL_STATUS_VOTING_PERIOD";
    CosmosGovV1beta1ProposalStatus["Passed"] = "PROPOSAL_STATUS_PASSED";
    CosmosGovV1beta1ProposalStatus["Rejected"] = "PROPOSAL_STATUS_REJECTED";
    CosmosGovV1beta1ProposalStatus["Failed"] = "PROPOSAL_STATUS_FAILED";
})(CosmosGovV1beta1ProposalStatus = exports.CosmosGovV1beta1ProposalStatus || (exports.CosmosGovV1beta1ProposalStatus = {}));
/**
    * @export
    * @enum {string}
    */
var CosmosGovV1beta1VoteOptionEnum;
(function (CosmosGovV1beta1VoteOptionEnum) {
    CosmosGovV1beta1VoteOptionEnum["Unspecified"] = "VOTE_OPTION_UNSPECIFIED";
    CosmosGovV1beta1VoteOptionEnum["Yes"] = "VOTE_OPTION_YES";
    CosmosGovV1beta1VoteOptionEnum["Abstain"] = "VOTE_OPTION_ABSTAIN";
    CosmosGovV1beta1VoteOptionEnum["No"] = "VOTE_OPTION_NO";
    CosmosGovV1beta1VoteOptionEnum["NoWithVeto"] = "VOTE_OPTION_NO_WITH_VETO";
})(CosmosGovV1beta1VoteOptionEnum = exports.CosmosGovV1beta1VoteOptionEnum || (exports.CosmosGovV1beta1VoteOptionEnum = {}));
/**
 * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
 * @export
 * @enum {string}
 */
var CosmosGovV1beta1VoteOption;
(function (CosmosGovV1beta1VoteOption) {
    CosmosGovV1beta1VoteOption["Unspecified"] = "VOTE_OPTION_UNSPECIFIED";
    CosmosGovV1beta1VoteOption["Yes"] = "VOTE_OPTION_YES";
    CosmosGovV1beta1VoteOption["Abstain"] = "VOTE_OPTION_ABSTAIN";
    CosmosGovV1beta1VoteOption["No"] = "VOTE_OPTION_NO";
    CosmosGovV1beta1VoteOption["NoWithVeto"] = "VOTE_OPTION_NO_WITH_VETO";
})(CosmosGovV1beta1VoteOption = exports.CosmosGovV1beta1VoteOption || (exports.CosmosGovV1beta1VoteOption = {}));
/**
    * @export
    * @enum {string}
    */
var CosmosGovV1beta1WeightedVoteOptionOptionEnum;
(function (CosmosGovV1beta1WeightedVoteOptionOptionEnum) {
    CosmosGovV1beta1WeightedVoteOptionOptionEnum["Unspecified"] = "VOTE_OPTION_UNSPECIFIED";
    CosmosGovV1beta1WeightedVoteOptionOptionEnum["Yes"] = "VOTE_OPTION_YES";
    CosmosGovV1beta1WeightedVoteOptionOptionEnum["Abstain"] = "VOTE_OPTION_ABSTAIN";
    CosmosGovV1beta1WeightedVoteOptionOptionEnum["No"] = "VOTE_OPTION_NO";
    CosmosGovV1beta1WeightedVoteOptionOptionEnum["NoWithVeto"] = "VOTE_OPTION_NO_WITH_VETO";
})(CosmosGovV1beta1WeightedVoteOptionOptionEnum = exports.CosmosGovV1beta1WeightedVoteOptionOptionEnum || (exports.CosmosGovV1beta1WeightedVoteOptionOptionEnum = {}));
/**
 * BondStatus is the status of a validator.   - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
 * @export
 * @enum {string}
 */
var CosmosStakingV1beta1BondStatus;
(function (CosmosStakingV1beta1BondStatus) {
    CosmosStakingV1beta1BondStatus["Unspecified"] = "BOND_STATUS_UNSPECIFIED";
    CosmosStakingV1beta1BondStatus["Unbonded"] = "BOND_STATUS_UNBONDED";
    CosmosStakingV1beta1BondStatus["Unbonding"] = "BOND_STATUS_UNBONDING";
    CosmosStakingV1beta1BondStatus["Bonded"] = "BOND_STATUS_BONDED";
})(CosmosStakingV1beta1BondStatus = exports.CosmosStakingV1beta1BondStatus || (exports.CosmosStakingV1beta1BondStatus = {}));
/**
    * @export
    * @enum {string}
    */
var CosmosStakingV1beta1ValidatorStatusEnum;
(function (CosmosStakingV1beta1ValidatorStatusEnum) {
    CosmosStakingV1beta1ValidatorStatusEnum["Unspecified"] = "BOND_STATUS_UNSPECIFIED";
    CosmosStakingV1beta1ValidatorStatusEnum["Unbonded"] = "BOND_STATUS_UNBONDED";
    CosmosStakingV1beta1ValidatorStatusEnum["Unbonding"] = "BOND_STATUS_UNBONDING";
    CosmosStakingV1beta1ValidatorStatusEnum["Bonded"] = "BOND_STATUS_BONDED";
})(CosmosStakingV1beta1ValidatorStatusEnum = exports.CosmosStakingV1beta1ValidatorStatusEnum || (exports.CosmosStakingV1beta1ValidatorStatusEnum = {}));
/**
 * SignMode represents a signing mode with its own security guarantees.   - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future
 * @export
 * @enum {string}
 */
var CosmosTxSigningV1beta1SignMode;
(function (CosmosTxSigningV1beta1SignMode) {
    CosmosTxSigningV1beta1SignMode["Unspecified"] = "SIGN_MODE_UNSPECIFIED";
    CosmosTxSigningV1beta1SignMode["Direct"] = "SIGN_MODE_DIRECT";
    CosmosTxSigningV1beta1SignMode["Textual"] = "SIGN_MODE_TEXTUAL";
    CosmosTxSigningV1beta1SignMode["LegacyAminoJson"] = "SIGN_MODE_LEGACY_AMINO_JSON";
})(CosmosTxSigningV1beta1SignMode = exports.CosmosTxSigningV1beta1SignMode || (exports.CosmosTxSigningV1beta1SignMode = {}));
/**
 * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.   - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering  - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block.  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only.  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately.
 * @export
 * @enum {string}
 */
var CosmosTxV1beta1BroadcastMode;
(function (CosmosTxV1beta1BroadcastMode) {
    CosmosTxV1beta1BroadcastMode["Unspecified"] = "BROADCAST_MODE_UNSPECIFIED";
    CosmosTxV1beta1BroadcastMode["Block"] = "BROADCAST_MODE_BLOCK";
    CosmosTxV1beta1BroadcastMode["Sync"] = "BROADCAST_MODE_SYNC";
    CosmosTxV1beta1BroadcastMode["Async"] = "BROADCAST_MODE_ASYNC";
})(CosmosTxV1beta1BroadcastMode = exports.CosmosTxV1beta1BroadcastMode || (exports.CosmosTxV1beta1BroadcastMode = {}));
/**
    * @export
    * @enum {string}
    */
var CosmosTxV1beta1BroadcastTxRequestModeEnum;
(function (CosmosTxV1beta1BroadcastTxRequestModeEnum) {
    CosmosTxV1beta1BroadcastTxRequestModeEnum["Unspecified"] = "BROADCAST_MODE_UNSPECIFIED";
    CosmosTxV1beta1BroadcastTxRequestModeEnum["Block"] = "BROADCAST_MODE_BLOCK";
    CosmosTxV1beta1BroadcastTxRequestModeEnum["Sync"] = "BROADCAST_MODE_SYNC";
    CosmosTxV1beta1BroadcastTxRequestModeEnum["Async"] = "BROADCAST_MODE_ASYNC";
})(CosmosTxV1beta1BroadcastTxRequestModeEnum = exports.CosmosTxV1beta1BroadcastTxRequestModeEnum || (exports.CosmosTxV1beta1BroadcastTxRequestModeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CosmosTxV1beta1ModeInfoSingleModeEnum;
(function (CosmosTxV1beta1ModeInfoSingleModeEnum) {
    CosmosTxV1beta1ModeInfoSingleModeEnum["Unspecified"] = "SIGN_MODE_UNSPECIFIED";
    CosmosTxV1beta1ModeInfoSingleModeEnum["Direct"] = "SIGN_MODE_DIRECT";
    CosmosTxV1beta1ModeInfoSingleModeEnum["Textual"] = "SIGN_MODE_TEXTUAL";
    CosmosTxV1beta1ModeInfoSingleModeEnum["LegacyAminoJson"] = "SIGN_MODE_LEGACY_AMINO_JSON";
})(CosmosTxV1beta1ModeInfoSingleModeEnum = exports.CosmosTxV1beta1ModeInfoSingleModeEnum || (exports.CosmosTxV1beta1ModeInfoSingleModeEnum = {}));
/**
 * - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
 * @export
 * @enum {string}
 */
var CosmosTxV1beta1OrderBy;
(function (CosmosTxV1beta1OrderBy) {
    CosmosTxV1beta1OrderBy["Unspecified"] = "ORDER_BY_UNSPECIFIED";
    CosmosTxV1beta1OrderBy["Asc"] = "ORDER_BY_ASC";
    CosmosTxV1beta1OrderBy["Desc"] = "ORDER_BY_DESC";
})(CosmosTxV1beta1OrderBy = exports.CosmosTxV1beta1OrderBy || (exports.CosmosTxV1beta1OrderBy = {}));
/**
    * @export
    * @enum {string}
    */
var InlineObject16ModeEnum;
(function (InlineObject16ModeEnum) {
    InlineObject16ModeEnum["Unspecified"] = "BROADCAST_MODE_UNSPECIFIED";
    InlineObject16ModeEnum["Block"] = "BROADCAST_MODE_BLOCK";
    InlineObject16ModeEnum["Sync"] = "BROADCAST_MODE_SYNC";
    InlineObject16ModeEnum["Async"] = "BROADCAST_MODE_ASYNC";
})(InlineObject16ModeEnum = exports.InlineObject16ModeEnum || (exports.InlineObject16ModeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum;
(function (InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum) {
    InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum["Unknown"] = "SIGNED_MSG_TYPE_UNKNOWN";
    InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum["Prevote"] = "SIGNED_MSG_TYPE_PREVOTE";
    InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum["Precommit"] = "SIGNED_MSG_TYPE_PRECOMMIT";
    InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum["Proposal"] = "SIGNED_MSG_TYPE_PROPOSAL";
})(InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum = exports.InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum || (exports.InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum;
(function (InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum) {
    InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum["Unknown"] = "BLOCK_ID_FLAG_UNKNOWN";
    InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum["Absent"] = "BLOCK_ID_FLAG_ABSENT";
    InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum["Commit"] = "BLOCK_ID_FLAG_COMMIT";
    InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum["Nil"] = "BLOCK_ID_FLAG_NIL";
})(InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum = exports.InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum || (exports.InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InlineResponse20052ProposalsStatusEnum;
(function (InlineResponse20052ProposalsStatusEnum) {
    InlineResponse20052ProposalsStatusEnum["Unspecified"] = "PROPOSAL_STATUS_UNSPECIFIED";
    InlineResponse20052ProposalsStatusEnum["DepositPeriod"] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
    InlineResponse20052ProposalsStatusEnum["VotingPeriod"] = "PROPOSAL_STATUS_VOTING_PERIOD";
    InlineResponse20052ProposalsStatusEnum["Passed"] = "PROPOSAL_STATUS_PASSED";
    InlineResponse20052ProposalsStatusEnum["Rejected"] = "PROPOSAL_STATUS_REJECTED";
    InlineResponse20052ProposalsStatusEnum["Failed"] = "PROPOSAL_STATUS_FAILED";
})(InlineResponse20052ProposalsStatusEnum = exports.InlineResponse20052ProposalsStatusEnum || (exports.InlineResponse20052ProposalsStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InlineResponse20057OptionsOptionEnum;
(function (InlineResponse20057OptionsOptionEnum) {
    InlineResponse20057OptionsOptionEnum["Unspecified"] = "VOTE_OPTION_UNSPECIFIED";
    InlineResponse20057OptionsOptionEnum["Yes"] = "VOTE_OPTION_YES";
    InlineResponse20057OptionsOptionEnum["Abstain"] = "VOTE_OPTION_ABSTAIN";
    InlineResponse20057OptionsOptionEnum["No"] = "VOTE_OPTION_NO";
    InlineResponse20057OptionsOptionEnum["NoWithVeto"] = "VOTE_OPTION_NO_WITH_VETO";
})(InlineResponse20057OptionsOptionEnum = exports.InlineResponse20057OptionsOptionEnum || (exports.InlineResponse20057OptionsOptionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InlineResponse20057VotesOptionEnum;
(function (InlineResponse20057VotesOptionEnum) {
    InlineResponse20057VotesOptionEnum["Unspecified"] = "VOTE_OPTION_UNSPECIFIED";
    InlineResponse20057VotesOptionEnum["Yes"] = "VOTE_OPTION_YES";
    InlineResponse20057VotesOptionEnum["Abstain"] = "VOTE_OPTION_ABSTAIN";
    InlineResponse20057VotesOptionEnum["No"] = "VOTE_OPTION_NO";
    InlineResponse20057VotesOptionEnum["NoWithVeto"] = "VOTE_OPTION_NO_WITH_VETO";
})(InlineResponse20057VotesOptionEnum = exports.InlineResponse20057VotesOptionEnum || (exports.InlineResponse20057VotesOptionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InlineResponse20066ValidatorsStatusEnum;
(function (InlineResponse20066ValidatorsStatusEnum) {
    InlineResponse20066ValidatorsStatusEnum["Unspecified"] = "BOND_STATUS_UNSPECIFIED";
    InlineResponse20066ValidatorsStatusEnum["Unbonded"] = "BOND_STATUS_UNBONDED";
    InlineResponse20066ValidatorsStatusEnum["Unbonding"] = "BOND_STATUS_UNBONDING";
    InlineResponse20066ValidatorsStatusEnum["Bonded"] = "BOND_STATUS_BONDED";
})(InlineResponse20066ValidatorsStatusEnum = exports.InlineResponse20066ValidatorsStatusEnum || (exports.InlineResponse20066ValidatorsStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SingleRepresentsASingleSignerModeEnum;
(function (SingleRepresentsASingleSignerModeEnum) {
    SingleRepresentsASingleSignerModeEnum["Unspecified"] = "SIGN_MODE_UNSPECIFIED";
    SingleRepresentsASingleSignerModeEnum["Direct"] = "SIGN_MODE_DIRECT";
    SingleRepresentsASingleSignerModeEnum["Textual"] = "SIGN_MODE_TEXTUAL";
    SingleRepresentsASingleSignerModeEnum["LegacyAminoJson"] = "SIGN_MODE_LEGACY_AMINO_JSON";
})(SingleRepresentsASingleSignerModeEnum = exports.SingleRepresentsASingleSignerModeEnum || (exports.SingleRepresentsASingleSignerModeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var TendermintTypesBlockIDFlag;
(function (TendermintTypesBlockIDFlag) {
    TendermintTypesBlockIDFlag["Unknown"] = "BLOCK_ID_FLAG_UNKNOWN";
    TendermintTypesBlockIDFlag["Absent"] = "BLOCK_ID_FLAG_ABSENT";
    TendermintTypesBlockIDFlag["Commit"] = "BLOCK_ID_FLAG_COMMIT";
    TendermintTypesBlockIDFlag["Nil"] = "BLOCK_ID_FLAG_NIL";
})(TendermintTypesBlockIDFlag = exports.TendermintTypesBlockIDFlag || (exports.TendermintTypesBlockIDFlag = {}));
/**
    * @export
    * @enum {string}
    */
var TendermintTypesCommitSigBlockIdFlagEnum;
(function (TendermintTypesCommitSigBlockIdFlagEnum) {
    TendermintTypesCommitSigBlockIdFlagEnum["Unknown"] = "BLOCK_ID_FLAG_UNKNOWN";
    TendermintTypesCommitSigBlockIdFlagEnum["Absent"] = "BLOCK_ID_FLAG_ABSENT";
    TendermintTypesCommitSigBlockIdFlagEnum["Commit"] = "BLOCK_ID_FLAG_COMMIT";
    TendermintTypesCommitSigBlockIdFlagEnum["Nil"] = "BLOCK_ID_FLAG_NIL";
})(TendermintTypesCommitSigBlockIdFlagEnum = exports.TendermintTypesCommitSigBlockIdFlagEnum || (exports.TendermintTypesCommitSigBlockIdFlagEnum = {}));
/**
 * SignedMsgType is a type of signed message in the consensus.   - SIGNED_MSG_TYPE_PREVOTE: Votes  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
 * @export
 * @enum {string}
 */
var TendermintTypesSignedMsgType;
(function (TendermintTypesSignedMsgType) {
    TendermintTypesSignedMsgType["Unknown"] = "SIGNED_MSG_TYPE_UNKNOWN";
    TendermintTypesSignedMsgType["Prevote"] = "SIGNED_MSG_TYPE_PREVOTE";
    TendermintTypesSignedMsgType["Precommit"] = "SIGNED_MSG_TYPE_PRECOMMIT";
    TendermintTypesSignedMsgType["Proposal"] = "SIGNED_MSG_TYPE_PROPOSAL";
})(TendermintTypesSignedMsgType = exports.TendermintTypesSignedMsgType || (exports.TendermintTypesSignedMsgType = {}));
/**
    * @export
    * @enum {string}
    */
var TendermintTypesVoteTypeEnum;
(function (TendermintTypesVoteTypeEnum) {
    TendermintTypesVoteTypeEnum["Unknown"] = "SIGNED_MSG_TYPE_UNKNOWN";
    TendermintTypesVoteTypeEnum["Prevote"] = "SIGNED_MSG_TYPE_PREVOTE";
    TendermintTypesVoteTypeEnum["Precommit"] = "SIGNED_MSG_TYPE_PRECOMMIT";
    TendermintTypesVoteTypeEnum["Proposal"] = "SIGNED_MSG_TYPE_PROPOSAL";
})(TendermintTypesVoteTypeEnum = exports.TendermintTypesVoteTypeEnum || (exports.TendermintTypesVoteTypeEnum = {}));
/**
 * AuthApi - axios parameter creator
 * @export
 */
var AuthApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccountsAddressGet: function (address, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'address' is not null or undefined
                    if (address === null || address === undefined) {
                        throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling authAccountsAddressGet.');
                    }
                    localVarPath = "/auth/accounts/{address}"
                        .replace("{" + "address" + "}", encodeURIComponent(String(address)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.AuthApiAxiosParamCreator = AuthApiAxiosParamCreator;
/**
 * AuthApi - functional programming interface
 * @export
 */
var AuthApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccountsAddressGet: function (address, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.AuthApiAxiosParamCreator)(configuration).authAccountsAddressGet(address, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.AuthApiFp = AuthApiFp;
/**
 * AuthApi - factory interface
 * @export
 */
var AuthApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccountsAddressGet: function (address, options) {
            return (0, exports.AuthApiFp)(configuration).authAccountsAddressGet(address, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AuthApiFactory = AuthApiFactory;
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
var AuthApi = /** @class */ (function (_super) {
    __extends(AuthApi, _super);
    function AuthApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get the account information on blockchain
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    AuthApi.prototype.authAccountsAddressGet = function (address, options) {
        var _this = this;
        return (0, exports.AuthApiFp)(this.configuration).authAccountsAddressGet(address, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AuthApi;
}(base_1.BaseAPI));
exports.AuthApi = AuthApi;
/**
 * BankApi - axios parameter creator
 * @export
 */
var BankApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsAddressTransfersPost: function (address, account, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'address' is not null or undefined
                    if (address === null || address === undefined) {
                        throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling bankAccountsAddressTransfersPost.');
                    }
                    // verify required parameter 'account' is not null or undefined
                    if (account === null || account === undefined) {
                        throw new base_1.RequiredError('account', 'Required parameter account was null or undefined when calling bankAccountsAddressTransfersPost.');
                    }
                    localVarPath = "/bank/accounts/{address}/transfers"
                        .replace("{" + "address" + "}", encodeURIComponent(String(address)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof account !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(account !== undefined ? account : {})
                        : (account || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankBalancesAddressGet: function (address, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'address' is not null or undefined
                    if (address === null || address === undefined) {
                        throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling bankBalancesAddressGet.');
                    }
                    localVarPath = "/bank/balances/{address}"
                        .replace("{" + "address" + "}", encodeURIComponent(String(address)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTotalDenominationGet: function (denomination, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'denomination' is not null or undefined
                    if (denomination === null || denomination === undefined) {
                        throw new base_1.RequiredError('denomination', 'Required parameter denomination was null or undefined when calling bankTotalDenominationGet.');
                    }
                    localVarPath = "/bank/total/{denomination}"
                        .replace("{" + "denomination" + "}", encodeURIComponent(String(denomination)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTotalGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/bank/total";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.BankApiAxiosParamCreator = BankApiAxiosParamCreator;
/**
 * BankApi - functional programming interface
 * @export
 */
var BankApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsAddressTransfersPost: function (address, account, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.BankApiAxiosParamCreator)(configuration).bankAccountsAddressTransfersPost(address, account, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankBalancesAddressGet: function (address, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.BankApiAxiosParamCreator)(configuration).bankBalancesAddressGet(address, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTotalDenominationGet: function (denomination, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.BankApiAxiosParamCreator)(configuration).bankTotalDenominationGet(denomination, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTotalGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.BankApiAxiosParamCreator)(configuration).bankTotalGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.BankApiFp = BankApiFp;
/**
 * BankApi - factory interface
 * @export
 */
var BankApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsAddressTransfersPost: function (address, account, options) {
            return (0, exports.BankApiFp)(configuration).bankAccountsAddressTransfersPost(address, account, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankBalancesAddressGet: function (address, options) {
            return (0, exports.BankApiFp)(configuration).bankBalancesAddressGet(address, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTotalDenominationGet: function (denomination, options) {
            return (0, exports.BankApiFp)(configuration).bankTotalDenominationGet(denomination, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTotalGet: function (options) {
            return (0, exports.BankApiFp)(configuration).bankTotalGet(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.BankApiFactory = BankApiFactory;
/**
 * BankApi - object-oriented interface
 * @export
 * @class BankApi
 * @extends {BaseAPI}
 */
var BankApi = /** @class */ (function (_super) {
    __extends(BankApi, _super);
    function BankApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Send coins from one account to another
     * @param {string} address Account address in bech32 format
     * @param {InlineObject3} account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    BankApi.prototype.bankAccountsAddressTransfersPost = function (address, account, options) {
        var _this = this;
        return (0, exports.BankApiFp)(this.configuration).bankAccountsAddressTransfersPost(address, account, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get the account balances
     * @param {string} address Account address in bech32 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    BankApi.prototype.bankBalancesAddressGet = function (address, options) {
        var _this = this;
        return (0, exports.BankApiFp)(this.configuration).bankBalancesAddressGet(address, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Total supply of a single coin denomination
     * @param {string} denomination Coin denomination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    BankApi.prototype.bankTotalDenominationGet = function (denomination, options) {
        var _this = this;
        return (0, exports.BankApiFp)(this.configuration).bankTotalDenominationGet(denomination, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Total supply of coins in the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    BankApi.prototype.bankTotalGet = function (options) {
        var _this = this;
        return (0, exports.BankApiFp)(this.configuration).bankTotalGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return BankApi;
}(base_1.BaseAPI));
exports.BankApi = BankApi;
/**
 * DistributionApi - axios parameter creator
 * @export
 */
var DistributionApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionCommunityPoolGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/distribution/community_pool";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsGet: function (delegatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsGet.');
                    }
                    localVarPath = "/distribution/delegators/{delegatorAddr}/rewards"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsPost: function (delegatorAddr, withdrawRequestBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsPost.');
                    }
                    localVarPath = "/distribution/delegators/{delegatorAddr}/rewards"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof withdrawRequestBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(withdrawRequestBody !== undefined ? withdrawRequestBody : {})
                        : (withdrawRequestBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet.');
                    }
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet.');
                    }
                    localVarPath = "/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)))
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost: function (delegatorAddr, validatorAddr, withdrawRequestBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost.');
                    }
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost.');
                    }
                    localVarPath = "/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)))
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof withdrawRequestBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(withdrawRequestBody !== undefined ? withdrawRequestBody : {})
                        : (withdrawRequestBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressGet: function (delegatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrWithdrawAddressGet.');
                    }
                    localVarPath = "/distribution/delegators/{delegatorAddr}/withdraw_address"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressPost: function (delegatorAddr, withdrawRequestBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrWithdrawAddressPost.');
                    }
                    localVarPath = "/distribution/delegators/{delegatorAddr}/withdraw_address"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof withdrawRequestBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(withdrawRequestBody !== undefined ? withdrawRequestBody : {})
                        : (withdrawRequestBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParametersGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/distribution/parameters";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrGet: function (validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrGet.');
                    }
                    localVarPath = "/distribution/validators/{validatorAddr}"
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrOutstandingRewardsGet: function (validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrOutstandingRewardsGet.');
                    }
                    localVarPath = "/distribution/validators/{validatorAddr}/outstanding_rewards"
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsGet: function (validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrRewardsGet.');
                    }
                    localVarPath = "/distribution/validators/{validatorAddr}/rewards"
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsPost: function (validatorAddr, withdrawRequestBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrRewardsPost.');
                    }
                    localVarPath = "/distribution/validators/{validatorAddr}/rewards"
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof withdrawRequestBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(withdrawRequestBody !== undefined ? withdrawRequestBody : {})
                        : (withdrawRequestBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.DistributionApiAxiosParamCreator = DistributionApiAxiosParamCreator;
/**
 * DistributionApi - functional programming interface
 * @export
 */
var DistributionApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionCommunityPoolGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionCommunityPoolGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsGet: function (delegatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsPost: function (delegatorAddr, withdrawRequestBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost: function (delegatorAddr, validatorAddr, withdrawRequestBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressGet: function (delegatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressPost: function (delegatorAddr, withdrawRequestBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParametersGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionParametersGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrGet: function (validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionValidatorsValidatorAddrGet(validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrOutstandingRewardsGet: function (validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsGet: function (validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsPost: function (validatorAddr, withdrawRequestBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.DistributionApiAxiosParamCreator)(configuration).distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.DistributionApiFp = DistributionApiFp;
/**
 * DistributionApi - factory interface
 * @export
 */
var DistributionApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionCommunityPoolGet: function (options) {
            return (0, exports.DistributionApiFp)(configuration).distributionCommunityPoolGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsGet: function (delegatorAddr, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsPost: function (delegatorAddr, withdrawRequestBody, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost: function (delegatorAddr, validatorAddr, withdrawRequestBody, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressGet: function (delegatorAddr, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressPost: function (delegatorAddr, withdrawRequestBody, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParametersGet: function (options) {
            return (0, exports.DistributionApiFp)(configuration).distributionParametersGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrGet: function (validatorAddr, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionValidatorsValidatorAddrGet(validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrOutstandingRewardsGet: function (validatorAddr, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsGet: function (validatorAddr, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsPost: function (validatorAddr, withdrawRequestBody, options) {
            return (0, exports.DistributionApiFp)(configuration).distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.DistributionApiFactory = DistributionApiFactory;
/**
 * DistributionApi - object-oriented interface
 * @export
 * @class DistributionApi
 * @extends {BaseAPI}
 */
var DistributionApi = /** @class */ (function (_super) {
    __extends(DistributionApi, _super);
    function DistributionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Community pool parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionCommunityPoolGet = function (options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionCommunityPoolGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the sum of all the rewards earned by delegations by a single delegator
     * @summary Get the total rewards balance from all delegations
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionDelegatorsDelegatorAddrRewardsGet = function (delegatorAddr, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Withdraw all the delegator\'s delegation rewards
     * @summary Withdraw all the delegator\'s delegation rewards
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject12} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionDelegatorsDelegatorAddrRewardsPost = function (delegatorAddr, withdrawRequestBody, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query a single delegation reward by a delegator
     * @summary Query a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet = function (delegatorAddr, validatorAddr, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Withdraw a delegator\'s delegation reward from a single validator
     * @summary Withdraw a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {InlineObject13} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost = function (delegatorAddr, validatorAddr, withdrawRequestBody, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
     * @summary Get the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionDelegatorsDelegatorAddrWithdrawAddressGet = function (delegatorAddr, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Replace the delegations\' rewards withdrawal address for a new one.
     * @summary Replace the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject14} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionDelegatorsDelegatorAddrWithdrawAddressPost = function (delegatorAddr, withdrawRequestBody, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Fee distribution parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionParametersGet = function (options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionParametersGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query the distribution information of a single validator
     * @summary Validator distribution information
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionValidatorsValidatorAddrGet = function (validatorAddr, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionValidatorsValidatorAddrGet(validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Fee distribution outstanding rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionValidatorsValidatorAddrOutstandingRewardsGet = function (validatorAddr, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query the commission and self-delegation rewards of validator.
     * @summary Commission and self-delegation rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionValidatorsValidatorAddrRewardsGet = function (validatorAddr, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Withdraw the validator\'s self-delegation and commissions rewards
     * @summary Withdraw the validator\'s rewards
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {InlineObject15} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    DistributionApi.prototype.distributionValidatorsValidatorAddrRewardsPost = function (validatorAddr, withdrawRequestBody, options) {
        var _this = this;
        return (0, exports.DistributionApiFp)(this.configuration).distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return DistributionApi;
}(base_1.BaseAPI));
exports.DistributionApi = DistributionApi;
/**
 * GaiaRESTApi - axios parameter creator
 * @export
 */
var GaiaRESTApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeInfoGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/node_info";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.GaiaRESTApiAxiosParamCreator = GaiaRESTApiAxiosParamCreator;
/**
 * GaiaRESTApi - functional programming interface
 * @export
 */
var GaiaRESTApiFp = function (configuration) {
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeInfoGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GaiaRESTApiAxiosParamCreator)(configuration).nodeInfoGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.GaiaRESTApiFp = GaiaRESTApiFp;
/**
 * GaiaRESTApi - factory interface
 * @export
 */
var GaiaRESTApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeInfoGet: function (options) {
            return (0, exports.GaiaRESTApiFp)(configuration).nodeInfoGet(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.GaiaRESTApiFactory = GaiaRESTApiFactory;
/**
 * GaiaRESTApi - object-oriented interface
 * @export
 * @class GaiaRESTApi
 * @extends {BaseAPI}
 */
var GaiaRESTApi = /** @class */ (function (_super) {
    __extends(GaiaRESTApi, _super);
    function GaiaRESTApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Information about the connected node
     * @summary The properties of the connected node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GaiaRESTApi
     */
    GaiaRESTApi.prototype.nodeInfoGet = function (options) {
        var _this = this;
        return (0, exports.GaiaRESTApiFp)(this.configuration).nodeInfoGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return GaiaRESTApi;
}(base_1.BaseAPI));
exports.GaiaRESTApi = GaiaRESTApi;
/**
 * GovernanceApi - axios parameter creator
 * @export
 */
var GovernanceApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersDepositGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/gov/parameters/deposit";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersTallyingGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/gov/parameters/tallying";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersVotingGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/gov/parameters/voting";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsGet: function (voter, depositor, status, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/gov/proposals";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (voter !== undefined) {
                        localVarQueryParameter['voter'] = voter;
                    }
                    if (depositor !== undefined) {
                        localVarQueryParameter['depositor'] = depositor;
                    }
                    if (status !== undefined) {
                        localVarQueryParameter['status'] = status;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsParamChangePost: function (postProposalBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'postProposalBody' is not null or undefined
                    if (postProposalBody === null || postProposalBody === undefined) {
                        throw new base_1.RequiredError('postProposalBody', 'Required parameter postProposalBody was null or undefined when calling govProposalsParamChangePost.');
                    }
                    localVarPath = "/gov/proposals/param_change";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof postProposalBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(postProposalBody !== undefined ? postProposalBody : {})
                        : (postProposalBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsPost: function (postProposalBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'postProposalBody' is not null or undefined
                    if (postProposalBody === null || postProposalBody === undefined) {
                        throw new base_1.RequiredError('postProposalBody', 'Required parameter postProposalBody was null or undefined when calling govProposalsPost.');
                    }
                    localVarPath = "/gov/proposals";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof postProposalBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(postProposalBody !== undefined ? postProposalBody : {})
                        : (postProposalBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsDepositorGet: function (proposalId, depositor, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsDepositorGet.');
                    }
                    // verify required parameter 'depositor' is not null or undefined
                    if (depositor === null || depositor === undefined) {
                        throw new base_1.RequiredError('depositor', 'Required parameter depositor was null or undefined when calling govProposalsProposalIdDepositsDepositorGet.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}/deposits/{depositor}"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)))
                        .replace("{" + "depositor" + "}", encodeURIComponent(String(depositor)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsGet: function (proposalId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsGet.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}/deposits"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsPost: function (proposalId, postDepositBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsPost.');
                    }
                    // verify required parameter 'postDepositBody' is not null or undefined
                    if (postDepositBody === null || postDepositBody === undefined) {
                        throw new base_1.RequiredError('postDepositBody', 'Required parameter postDepositBody was null or undefined when calling govProposalsProposalIdDepositsPost.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}/deposits"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof postDepositBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(postDepositBody !== undefined ? postDepositBody : {})
                        : (postDepositBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdGet: function (proposalId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdGet.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdProposerGet: function (proposalId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdProposerGet.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}/proposer"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdTallyGet: function (proposalId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdTallyGet.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}/tally"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesGet: function (proposalId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesGet.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}/votes"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesPost: function (proposalId, postVoteBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesPost.');
                    }
                    // verify required parameter 'postVoteBody' is not null or undefined
                    if (postVoteBody === null || postVoteBody === undefined) {
                        throw new base_1.RequiredError('postVoteBody', 'Required parameter postVoteBody was null or undefined when calling govProposalsProposalIdVotesPost.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}/votes"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof postVoteBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(postVoteBody !== undefined ? postVoteBody : {})
                        : (postVoteBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesVoterGet: function (proposalId, voter, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesVoterGet.');
                    }
                    // verify required parameter 'voter' is not null or undefined
                    if (voter === null || voter === undefined) {
                        throw new base_1.RequiredError('voter', 'Required parameter voter was null or undefined when calling govProposalsProposalIdVotesVoterGet.');
                    }
                    localVarPath = "/gov/proposals/{proposalId}/votes/{voter}"
                        .replace("{" + "proposalId" + "}", encodeURIComponent(String(proposalId)))
                        .replace("{" + "voter" + "}", encodeURIComponent(String(voter)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.GovernanceApiAxiosParamCreator = GovernanceApiAxiosParamCreator;
/**
 * GovernanceApi - functional programming interface
 * @export
 */
var GovernanceApiFp = function (configuration) {
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersDepositGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govParametersDepositGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersTallyingGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govParametersTallyingGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersVotingGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govParametersVotingGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsGet: function (voter, depositor, status, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsGet(voter, depositor, status, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsParamChangePost: function (postProposalBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsParamChangePost(postProposalBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsPost: function (postProposalBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsPost(postProposalBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsDepositorGet: function (proposalId, depositor, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsGet: function (proposalId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdDepositsGet(proposalId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsPost: function (proposalId, postDepositBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdGet: function (proposalId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdGet(proposalId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdProposerGet: function (proposalId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdProposerGet(proposalId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdTallyGet: function (proposalId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdTallyGet(proposalId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesGet: function (proposalId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdVotesGet(proposalId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesPost: function (proposalId, postVoteBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdVotesPost(proposalId, postVoteBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesVoterGet: function (proposalId, voter, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.GovernanceApiAxiosParamCreator)(configuration).govProposalsProposalIdVotesVoterGet(proposalId, voter, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.GovernanceApiFp = GovernanceApiFp;
/**
 * GovernanceApi - factory interface
 * @export
 */
var GovernanceApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersDepositGet: function (options) {
            return (0, exports.GovernanceApiFp)(configuration).govParametersDepositGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersTallyingGet: function (options) {
            return (0, exports.GovernanceApiFp)(configuration).govParametersTallyingGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersVotingGet: function (options) {
            return (0, exports.GovernanceApiFp)(configuration).govParametersVotingGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsGet: function (voter, depositor, status, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsGet(voter, depositor, status, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsParamChangePost: function (postProposalBody, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsParamChangePost(postProposalBody, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsPost: function (postProposalBody, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsPost(postProposalBody, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsDepositorGet: function (proposalId, depositor, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsGet: function (proposalId, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdDepositsGet(proposalId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsPost: function (proposalId, postDepositBody, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdGet: function (proposalId, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdGet(proposalId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdProposerGet: function (proposalId, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdProposerGet(proposalId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdTallyGet: function (proposalId, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdTallyGet(proposalId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesGet: function (proposalId, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdVotesGet(proposalId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesPost: function (proposalId, postVoteBody, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdVotesPost(proposalId, postVoteBody, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesVoterGet: function (proposalId, voter, options) {
            return (0, exports.GovernanceApiFp)(configuration).govProposalsProposalIdVotesVoterGet(proposalId, voter, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.GovernanceApiFactory = GovernanceApiFactory;
/**
 * GovernanceApi - object-oriented interface
 * @export
 * @class GovernanceApi
 * @extends {BaseAPI}
 */
var GovernanceApi = /** @class */ (function (_super) {
    __extends(GovernanceApi, _super);
    function GovernanceApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
     * @summary Query governance deposit parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govParametersDepositGet = function (options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govParametersDepositGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query governance tally parameters
     * @summary Query governance tally parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govParametersTallyingGet = function (options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govParametersTallyingGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query governance voting parameters. The voting_period units are in nanoseconds.
     * @summary Query governance voting parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govParametersVotingGet = function (options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govParametersVotingGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query proposals information with parameters
     * @summary Query proposals
     * @param {string} [voter] voter address
     * @param {string} [depositor] depositor address
     * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsGet = function (voter, depositor, status, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsGet(voter, depositor, status, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Generate a parameter change proposal transaction
     * @summary Generate a parameter change proposal transaction
     * @param {InlineObject9} postProposalBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsParamChangePost = function (postProposalBody, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsParamChangePost(postProposalBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Send transaction to submit a proposal
     * @summary Submit a proposal
     * @param {InlineObject8} postProposalBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsPost = function (postProposalBody, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsPost(postProposalBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query deposit by proposalId and depositor address
     * @summary Query deposit
     * @param {string} proposalId proposal id
     * @param {string} depositor Bech32 depositor address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdDepositsDepositorGet = function (proposalId, depositor, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query deposits by proposalId
     * @summary Query deposits
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdDepositsGet = function (proposalId, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdDepositsGet(proposalId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Send transaction to deposit tokens to a proposal
     * @summary Deposit tokens to a proposal
     * @param {string} proposalId proposal id
     * @param {InlineObject10} postDepositBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdDepositsPost = function (proposalId, postDepositBody, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query a proposal by id
     * @summary Query a proposal
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdGet = function (proposalId, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdGet(proposalId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query for the proposer for a proposal
     * @summary Query proposer
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdProposerGet = function (proposalId, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdProposerGet(proposalId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
     * @summary Get a proposal\'s tally result at the current time
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdTallyGet = function (proposalId, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdTallyGet(proposalId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query voters information by proposalId
     * @summary Query voters
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdVotesGet = function (proposalId, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdVotesGet(proposalId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Send transaction to vote a proposal
     * @summary Vote a proposal
     * @param {string} proposalId proposal id
     * @param {InlineObject11} postVoteBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdVotesPost = function (proposalId, postVoteBody, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdVotesPost(proposalId, postVoteBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Query vote information by proposal Id and voter address
     * @summary Query vote
     * @param {string} proposalId proposal id
     * @param {string} voter Bech32 voter address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    GovernanceApi.prototype.govProposalsProposalIdVotesVoterGet = function (proposalId, voter, options) {
        var _this = this;
        return (0, exports.GovernanceApiFp)(this.configuration).govProposalsProposalIdVotesVoterGet(proposalId, voter, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return GovernanceApi;
}(base_1.BaseAPI));
exports.GovernanceApi = GovernanceApi;
/**
 * MintApi - axios parameter creator
 * @export
 */
var MintApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingAnnualProvisionsGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/minting/annual-provisions";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingInflationGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/minting/inflation";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingParametersGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/minting/parameters";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.MintApiAxiosParamCreator = MintApiAxiosParamCreator;
/**
 * MintApi - functional programming interface
 * @export
 */
var MintApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingAnnualProvisionsGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.MintApiAxiosParamCreator)(configuration).mintingAnnualProvisionsGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingInflationGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.MintApiAxiosParamCreator)(configuration).mintingInflationGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingParametersGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.MintApiAxiosParamCreator)(configuration).mintingParametersGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.MintApiFp = MintApiFp;
/**
 * MintApi - factory interface
 * @export
 */
var MintApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingAnnualProvisionsGet: function (options) {
            return (0, exports.MintApiFp)(configuration).mintingAnnualProvisionsGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingInflationGet: function (options) {
            return (0, exports.MintApiFp)(configuration).mintingInflationGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingParametersGet: function (options) {
            return (0, exports.MintApiFp)(configuration).mintingParametersGet(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.MintApiFactory = MintApiFactory;
/**
 * MintApi - object-oriented interface
 * @export
 * @class MintApi
 * @extends {BaseAPI}
 */
var MintApi = /** @class */ (function (_super) {
    __extends(MintApi, _super);
    function MintApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Current minting annual provisions value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintApi
     */
    MintApi.prototype.mintingAnnualProvisionsGet = function (options) {
        var _this = this;
        return (0, exports.MintApiFp)(this.configuration).mintingAnnualProvisionsGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Current minting inflation value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintApi
     */
    MintApi.prototype.mintingInflationGet = function (options) {
        var _this = this;
        return (0, exports.MintApiFp)(this.configuration).mintingInflationGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Minting module parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintApi
     */
    MintApi.prototype.mintingParametersGet = function (options) {
        var _this = this;
        return (0, exports.MintApiFp)(this.configuration).mintingParametersGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return MintApi;
}(base_1.BaseAPI));
exports.MintApi = MintApi;
/**
 * QueryApi - axios parameter creator
 * @export
 */
var QueryApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account: function (address, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'address' is not null or undefined
                    if (address === null || address === undefined) {
                        throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling account.');
                    }
                    localVarPath = "/cosmos/auth/v1beta1/accounts/{address}"
                        .replace("{" + "address" + "}", encodeURIComponent(String(address)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/auth/v1beta1/accounts";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances: function (address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'address' is not null or undefined
                    if (address === null || address === undefined) {
                        throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling allBalances.');
                    }
                    localVarPath = "/cosmos/bank/v1beta1/balances/{address}"
                        .replace("{" + "address" + "}", encodeURIComponent(String(address)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/evidence/v1beta1/evidence";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowance: function (granter, grantee, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'granter' is not null or undefined
                    if (granter === null || granter === undefined) {
                        throw new base_1.RequiredError('granter', 'Required parameter granter was null or undefined when calling allowance.');
                    }
                    // verify required parameter 'grantee' is not null or undefined
                    if (grantee === null || grantee === undefined) {
                        throw new base_1.RequiredError('grantee', 'Required parameter grantee was null or undefined when calling allowance.');
                    }
                    localVarPath = "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}"
                        .replace("{" + "granter" + "}", encodeURIComponent(String(granter)))
                        .replace("{" + "grantee" + "}", encodeURIComponent(String(grantee)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowances: function (grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'grantee' is not null or undefined
                    if (grantee === null || grantee === undefined) {
                        throw new base_1.RequiredError('grantee', 'Required parameter grantee was null or undefined when calling allowances.');
                    }
                    localVarPath = "/cosmos/feegrant/v1beta1/allowances/{grantee}"
                        .replace("{" + "grantee" + "}", encodeURIComponent(String(grantee)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/mint/v1beta1/annual_provisions";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan: function (name, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'name' is not null or undefined
                    if (name === null || name === undefined) {
                        throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling appliedPlan.');
                    }
                    localVarPath = "/cosmos/upgrade/v1beta1/applied_plan/{name}"
                        .replace("{" + "name" + "}", encodeURIComponent(String(name)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/auth/v1beta1/params";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance: function (address, denom, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'address' is not null or undefined
                    if (address === null || address === undefined) {
                        throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling balance.');
                    }
                    // verify required parameter 'denom' is not null or undefined
                    if (denom === null || denom === undefined) {
                        throw new base_1.RequiredError('denom', 'Required parameter denom was null or undefined when calling balance.');
                    }
                    localVarPath = "/cosmos/bank/v1beta1/balances/{address}/{denom}"
                        .replace("{" + "address" + "}", encodeURIComponent(String(address)))
                        .replace("{" + "denom" + "}", encodeURIComponent(String(denom)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/bank/v1beta1/params";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/distribution/v1beta1/community_pool";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/upgrade/v1beta1/current_plan";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation: function (validatorAddr, delegatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling delegation.');
                    }
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling delegation.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}"
                        .replace("{" + "validator_addr" + "}", encodeURIComponent(String(validatorAddr)))
                        .replace("{" + "delegator_addr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards: function (delegatorAddress, validatorAddress, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddress' is not null or undefined
                    if (delegatorAddress === null || delegatorAddress === undefined) {
                        throw new base_1.RequiredError('delegatorAddress', 'Required parameter delegatorAddress was null or undefined when calling delegationRewards.');
                    }
                    // verify required parameter 'validatorAddress' is not null or undefined
                    if (validatorAddress === null || validatorAddress === undefined) {
                        throw new base_1.RequiredError('validatorAddress', 'Required parameter validatorAddress was null or undefined when calling delegationRewards.');
                    }
                    localVarPath = "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}"
                        .replace("{" + "delegator_address" + "}", encodeURIComponent(String(delegatorAddress)))
                        .replace("{" + "validator_address" + "}", encodeURIComponent(String(validatorAddress)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards: function (delegatorAddress, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddress' is not null or undefined
                    if (delegatorAddress === null || delegatorAddress === undefined) {
                        throw new base_1.RequiredError('delegatorAddress', 'Required parameter delegatorAddress was null or undefined when calling delegationTotalRewards.');
                    }
                    localVarPath = "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards"
                        .replace("{" + "delegator_address" + "}", encodeURIComponent(String(delegatorAddress)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling delegatorDelegations.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/delegations/{delegator_addr}"
                        .replace("{" + "delegator_addr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling delegatorUnbondingDelegations.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations"
                        .replace("{" + "delegator_addr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator: function (delegatorAddr, validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling delegatorValidator.');
                    }
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling delegatorValidator.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}"
                        .replace("{" + "delegator_addr" + "}", encodeURIComponent(String(delegatorAddr)))
                        .replace("{" + "validator_addr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators: function (delegatorAddress, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddress' is not null or undefined
                    if (delegatorAddress === null || delegatorAddress === undefined) {
                        throw new base_1.RequiredError('delegatorAddress', 'Required parameter delegatorAddress was null or undefined when calling delegatorValidators.');
                    }
                    localVarPath = "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators"
                        .replace("{" + "delegator_address" + "}", encodeURIComponent(String(delegatorAddress)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress: function (delegatorAddress, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddress' is not null or undefined
                    if (delegatorAddress === null || delegatorAddress === undefined) {
                        throw new base_1.RequiredError('delegatorAddress', 'Required parameter delegatorAddress was null or undefined when calling delegatorWithdrawAddress.');
                    }
                    localVarPath = "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address"
                        .replace("{" + "delegator_address" + "}", encodeURIComponent(String(delegatorAddress)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomMetadata: function (denom, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'denom' is not null or undefined
                    if (denom === null || denom === undefined) {
                        throw new base_1.RequiredError('denom', 'Required parameter denom was null or undefined when calling denomMetadata.');
                    }
                    localVarPath = "/cosmos/bank/v1beta1/denoms_metadata/{denom}"
                        .replace("{" + "denom" + "}", encodeURIComponent(String(denom)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomOwners: function (denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'denom' is not null or undefined
                    if (denom === null || denom === undefined) {
                        throw new base_1.RequiredError('denom', 'Required parameter denom was null or undefined when calling denomOwners.');
                    }
                    localVarPath = "/cosmos/bank/v1beta1/denom_owners/{denom}"
                        .replace("{" + "denom" + "}", encodeURIComponent(String(denom)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomsMetadata: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/bank/v1beta1/denoms_metadata";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: function (proposalId, depositor, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling deposit.');
                    }
                    // verify required parameter 'depositor' is not null or undefined
                    if (depositor === null || depositor === undefined) {
                        throw new base_1.RequiredError('depositor', 'Required parameter depositor was null or undefined when calling deposit.');
                    }
                    localVarPath = "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}"
                        .replace("{" + "proposal_id" + "}", encodeURIComponent(String(proposalId)))
                        .replace("{" + "depositor" + "}", encodeURIComponent(String(depositor)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits: function (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling deposits.');
                    }
                    localVarPath = "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits"
                        .replace("{" + "proposal_id" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/distribution/v1beta1/params";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence: function (evidenceHash, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'evidenceHash' is not null or undefined
                    if (evidenceHash === null || evidenceHash === undefined) {
                        throw new base_1.RequiredError('evidenceHash', 'Required parameter evidenceHash was null or undefined when calling evidence.');
                    }
                    localVarPath = "/cosmos/evidence/v1beta1/evidence/{evidence_hash}"
                        .replace("{" + "evidence_hash" + "}", encodeURIComponent(String(evidenceHash)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams: function (paramsType, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'paramsType' is not null or undefined
                    if (paramsType === null || paramsType === undefined) {
                        throw new base_1.RequiredError('paramsType', 'Required parameter paramsType was null or undefined when calling govParams.');
                    }
                    localVarPath = "/cosmos/gov/v1beta1/params/{params_type}"
                        .replace("{" + "params_type" + "}", encodeURIComponent(String(paramsType)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter]
         * @param {string} [grantee]
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grants: function (granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/authz/v1beta1/grants";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (granter !== undefined) {
                        localVarQueryParameter['granter'] = granter;
                    }
                    if (grantee !== undefined) {
                        localVarQueryParameter['grantee'] = grantee;
                    }
                    if (msgTypeUrl !== undefined) {
                        localVarQueryParameter['msg_type_url'] = msgTypeUrl;
                    }
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo: function (height, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'height' is not null or undefined
                    if (height === null || height === undefined) {
                        throw new base_1.RequiredError('height', 'Required parameter height was null or undefined when calling historicalInfo.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/historical_info/{height}"
                        .replace("{" + "height" + "}", encodeURIComponent(String(height)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/mint/v1beta1/inflation";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/mint/v1beta1/params";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersions: function (moduleName, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/upgrade/v1beta1/module_versions";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (moduleName !== undefined) {
                        localVarQueryParameter['module_name'] = moduleName;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params: function (subspace, key, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key_1, key_2, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/params/v1beta1/params";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (subspace !== undefined) {
                        localVarQueryParameter['subspace'] = subspace;
                    }
                    if (key !== undefined) {
                        localVarQueryParameter['key'] = key;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key_1 in localVarQueryParameter) {
                        queryParameters.set(key_1, localVarQueryParameter[key_1]);
                    }
                    for (key_2 in options.query) {
                        queryParameters.set(key_2, options.query[key_2]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/staking/v1beta1/pool";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal: function (proposalId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling proposal.');
                    }
                    localVarPath = "/cosmos/gov/v1beta1/proposals/{proposal_id}"
                        .replace("{" + "proposal_id" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals: function (proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/gov/v1beta1/proposals";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (proposalStatus !== undefined) {
                        localVarQueryParameter['proposal_status'] = proposalStatus;
                    }
                    if (voter !== undefined) {
                        localVarQueryParameter['voter'] = voter;
                    }
                    if (depositor !== undefined) {
                        localVarQueryParameter['depositor'] = depositor;
                    }
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations: function (delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling redelegations.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations"
                        .replace("{" + "delegator_addr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (srcValidatorAddr !== undefined) {
                        localVarQueryParameter['src_validator_addr'] = srcValidatorAddr;
                    }
                    if (dstValidatorAddr !== undefined) {
                        localVarQueryParameter['dst_validator_addr'] = dstValidatorAddr;
                    }
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo: function (consAddress, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'consAddress' is not null or undefined
                    if (consAddress === null || consAddress === undefined) {
                        throw new base_1.RequiredError('consAddress', 'Required parameter consAddress was null or undefined when calling signingInfo.');
                    }
                    localVarPath = "/cosmos/slashing/v1beta1/signing_infos/{cons_address}"
                        .replace("{" + "cons_address" + "}", encodeURIComponent(String(consAddress)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/slashing/v1beta1/signing_infos";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/slashing/v1beta1/params";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorValidators.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators"
                        .replace("{" + "delegator_addr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/staking/v1beta1/params";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf: function (denom, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'denom' is not null or undefined
                    if (denom === null || denom === undefined) {
                        throw new base_1.RequiredError('denom', 'Required parameter denom was null or undefined when calling supplyOf.');
                    }
                    localVarPath = "/cosmos/bank/v1beta1/supply/{denom}"
                        .replace("{" + "denom" + "}", encodeURIComponent(String(denom)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult: function (proposalId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling tallyResult.');
                    }
                    localVarPath = "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally"
                        .replace("{" + "proposal_id" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/bank/v1beta1/supply";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation: function (validatorAddr, delegatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling unbondingDelegation.');
                    }
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling unbondingDelegation.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation"
                        .replace("{" + "validator_addr" + "}", encodeURIComponent(String(validatorAddr)))
                        .replace("{" + "delegator_addr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState: function (lastHeight, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'lastHeight' is not null or undefined
                    if (lastHeight === null || lastHeight === undefined) {
                        throw new base_1.RequiredError('lastHeight', 'Required parameter lastHeight was null or undefined when calling upgradedConsensusState.');
                    }
                    localVarPath = "/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}"
                        .replace("{" + "last_height" + "}", encodeURIComponent(String(lastHeight)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator: function (validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling validator.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/validators/{validator_addr}"
                        .replace("{" + "validator_addr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission: function (validatorAddress, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddress' is not null or undefined
                    if (validatorAddress === null || validatorAddress === undefined) {
                        throw new base_1.RequiredError('validatorAddress', 'Required parameter validatorAddress was null or undefined when calling validatorCommission.');
                    }
                    localVarPath = "/cosmos/distribution/v1beta1/validators/{validator_address}/commission"
                        .replace("{" + "validator_address" + "}", encodeURIComponent(String(validatorAddress)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations: function (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling validatorDelegations.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations"
                        .replace("{" + "validator_addr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards: function (validatorAddress, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddress' is not null or undefined
                    if (validatorAddress === null || validatorAddress === undefined) {
                        throw new base_1.RequiredError('validatorAddress', 'Required parameter validatorAddress was null or undefined when calling validatorOutstandingRewards.');
                    }
                    localVarPath = "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards"
                        .replace("{" + "validator_address" + "}", encodeURIComponent(String(validatorAddress)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes: function (validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddress' is not null or undefined
                    if (validatorAddress === null || validatorAddress === undefined) {
                        throw new base_1.RequiredError('validatorAddress', 'Required parameter validatorAddress was null or undefined when calling validatorSlashes.');
                    }
                    localVarPath = "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes"
                        .replace("{" + "validator_address" + "}", encodeURIComponent(String(validatorAddress)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (startingHeight !== undefined) {
                        localVarQueryParameter['starting_height'] = startingHeight;
                    }
                    if (endingHeight !== undefined) {
                        localVarQueryParameter['ending_height'] = endingHeight;
                    }
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations: function (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling validatorUnbondingDelegations.');
                    }
                    localVarPath = "/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations"
                        .replace("{" + "validator_addr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators: function (status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/staking/v1beta1/validators";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (status !== undefined) {
                        localVarQueryParameter['status'] = status;
                    }
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote: function (proposalId, voter, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling vote.');
                    }
                    // verify required parameter 'voter' is not null or undefined
                    if (voter === null || voter === undefined) {
                        throw new base_1.RequiredError('voter', 'Required parameter voter was null or undefined when calling vote.');
                    }
                    localVarPath = "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}"
                        .replace("{" + "proposal_id" + "}", encodeURIComponent(String(proposalId)))
                        .replace("{" + "voter" + "}", encodeURIComponent(String(voter)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes: function (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'proposalId' is not null or undefined
                    if (proposalId === null || proposalId === undefined) {
                        throw new base_1.RequiredError('proposalId', 'Required parameter proposalId was null or undefined when calling votes.');
                    }
                    localVarPath = "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes"
                        .replace("{" + "proposal_id" + "}", encodeURIComponent(String(proposalId)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.QueryApiAxiosParamCreator = QueryApiAxiosParamCreator;
/**
 * QueryApi - functional programming interface
 * @export
 */
var QueryApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account: function (address, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).account(address, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances: function (address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowance: function (granter, grantee, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).allowance(granter, grantee, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowances: function (grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).annualProvisions(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan: function (name, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).appliedPlan(name, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).authParams(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance: function (address, denom, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).balance(address, denom, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).bankParams(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).communityPool(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).currentPlan(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation: function (validatorAddr, delegatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).delegation(validatorAddr, delegatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards: function (delegatorAddress, validatorAddress, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).delegationRewards(delegatorAddress, validatorAddress, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards: function (delegatorAddress, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).delegationTotalRewards(delegatorAddress, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator: function (delegatorAddr, validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).delegatorValidator(delegatorAddr, validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators: function (delegatorAddress, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).delegatorValidators(delegatorAddress, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress: function (delegatorAddress, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).delegatorWithdrawAddress(delegatorAddress, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomMetadata: function (denom, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).denomMetadata(denom, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomOwners: function (denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomsMetadata: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: function (proposalId, depositor, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).deposit(proposalId, depositor, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits: function (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).distributionParams(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence: function (evidenceHash, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).evidence(evidenceHash, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams: function (paramsType, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).govParams(paramsType, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter]
         * @param {string} [grantee]
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grants: function (granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo: function (height, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).historicalInfo(height, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).inflation(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).mintParams(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersions: function (moduleName, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).moduleVersions(moduleName, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params: function (subspace, key, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).params(subspace, key, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).pool(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal: function (proposalId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).proposal(proposalId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals: function (proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations: function (delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo: function (consAddress, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).signingInfo(consAddress, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).slashingParams(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).stakingParams(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf: function (denom, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).supplyOf(denom, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult: function (proposalId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).tallyResult(proposalId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation: function (validatorAddr, delegatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).unbondingDelegation(validatorAddr, delegatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState: function (lastHeight, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).upgradedConsensusState(lastHeight, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator: function (validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).validator(validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission: function (validatorAddress, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).validatorCommission(validatorAddress, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations: function (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards: function (validatorAddress, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).validatorOutstandingRewards(validatorAddress, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes: function (validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations: function (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators: function (status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote: function (proposalId, voter, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).vote(proposalId, voter, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes: function (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.QueryApiAxiosParamCreator)(configuration).votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.QueryApiFp = QueryApiFp;
/**
 * QueryApi - factory interface
 * @export
 */
var QueryApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account: function (address, options) {
            return (0, exports.QueryApiFp)(configuration).account(address, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances: function (address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowance: function (granter, grantee, options) {
            return (0, exports.QueryApiFp)(configuration).allowance(granter, grantee, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowances: function (grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions: function (options) {
            return (0, exports.QueryApiFp)(configuration).annualProvisions(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan: function (name, options) {
            return (0, exports.QueryApiFp)(configuration).appliedPlan(name, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams: function (options) {
            return (0, exports.QueryApiFp)(configuration).authParams(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance: function (address, denom, options) {
            return (0, exports.QueryApiFp)(configuration).balance(address, denom, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams: function (options) {
            return (0, exports.QueryApiFp)(configuration).bankParams(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool: function (options) {
            return (0, exports.QueryApiFp)(configuration).communityPool(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan: function (options) {
            return (0, exports.QueryApiFp)(configuration).currentPlan(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation: function (validatorAddr, delegatorAddr, options) {
            return (0, exports.QueryApiFp)(configuration).delegation(validatorAddr, delegatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards: function (delegatorAddress, validatorAddress, options) {
            return (0, exports.QueryApiFp)(configuration).delegationRewards(delegatorAddress, validatorAddress, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards: function (delegatorAddress, options) {
            return (0, exports.QueryApiFp)(configuration).delegationTotalRewards(delegatorAddress, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator: function (delegatorAddr, validatorAddr, options) {
            return (0, exports.QueryApiFp)(configuration).delegatorValidator(delegatorAddr, validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators: function (delegatorAddress, options) {
            return (0, exports.QueryApiFp)(configuration).delegatorValidators(delegatorAddress, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress: function (delegatorAddress, options) {
            return (0, exports.QueryApiFp)(configuration).delegatorWithdrawAddress(delegatorAddress, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomMetadata: function (denom, options) {
            return (0, exports.QueryApiFp)(configuration).denomMetadata(denom, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomOwners: function (denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomsMetadata: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: function (proposalId, depositor, options) {
            return (0, exports.QueryApiFp)(configuration).deposit(proposalId, depositor, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits: function (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams: function (options) {
            return (0, exports.QueryApiFp)(configuration).distributionParams(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence: function (evidenceHash, options) {
            return (0, exports.QueryApiFp)(configuration).evidence(evidenceHash, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams: function (paramsType, options) {
            return (0, exports.QueryApiFp)(configuration).govParams(paramsType, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter]
         * @param {string} [grantee]
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grants: function (granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo: function (height, options) {
            return (0, exports.QueryApiFp)(configuration).historicalInfo(height, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation: function (options) {
            return (0, exports.QueryApiFp)(configuration).inflation(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams: function (options) {
            return (0, exports.QueryApiFp)(configuration).mintParams(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersions: function (moduleName, options) {
            return (0, exports.QueryApiFp)(configuration).moduleVersions(moduleName, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params: function (subspace, key, options) {
            return (0, exports.QueryApiFp)(configuration).params(subspace, key, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: function (options) {
            return (0, exports.QueryApiFp)(configuration).pool(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal: function (proposalId, options) {
            return (0, exports.QueryApiFp)(configuration).proposal(proposalId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals: function (proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations: function (delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo: function (consAddress, options) {
            return (0, exports.QueryApiFp)(configuration).signingInfo(consAddress, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams: function (options) {
            return (0, exports.QueryApiFp)(configuration).slashingParams(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators: function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams: function (options) {
            return (0, exports.QueryApiFp)(configuration).stakingParams(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf: function (denom, options) {
            return (0, exports.QueryApiFp)(configuration).supplyOf(denom, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult: function (proposalId, options) {
            return (0, exports.QueryApiFp)(configuration).tallyResult(proposalId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation: function (validatorAddr, delegatorAddr, options) {
            return (0, exports.QueryApiFp)(configuration).unbondingDelegation(validatorAddr, delegatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState: function (lastHeight, options) {
            return (0, exports.QueryApiFp)(configuration).upgradedConsensusState(lastHeight, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator: function (validatorAddr, options) {
            return (0, exports.QueryApiFp)(configuration).validator(validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission: function (validatorAddress, options) {
            return (0, exports.QueryApiFp)(configuration).validatorCommission(validatorAddress, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations: function (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards: function (validatorAddress, options) {
            return (0, exports.QueryApiFp)(configuration).validatorOutstandingRewards(validatorAddress, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes: function (validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations: function (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators: function (status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote: function (proposalId, voter, options) {
            return (0, exports.QueryApiFp)(configuration).vote(proposalId, voter, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes: function (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.QueryApiFp)(configuration).votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.QueryApiFactory = QueryApiFactory;
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
var QueryApi = /** @class */ (function (_super) {
    __extends(QueryApi, _super);
    function QueryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Account returns account details based on address.
     * @param {string} address address defines the address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.account = function (address, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).account(address, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Accounts returns all the existing accounts
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.accounts = function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary AllBalances queries the balance of all coins for a single account.
     * @param {string} address address is the address to query balances for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.allBalances = function (address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary AllEvidence queries all evidence.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.allEvidence = function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Allowance returns fee granted to the grantee by the granter.
     * @param {string} granter granter is the address of the user granting an allowance of their funds.
     * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.allowance = function (granter, grantee, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).allowance(granter, grantee, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Allowances returns all the grants for address.
     * @param {string} grantee
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.allowances = function (grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary AnnualProvisions current minting annual provisions value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.annualProvisions = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).annualProvisions(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary AppliedPlan queries a previously applied upgrade plan by its name.
     * @param {string} name name is the name of the applied plan to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.appliedPlan = function (name, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).appliedPlan(name, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Params queries all parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.authParams = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).authParams(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Balance queries the balance of a single coin for a single account.
     * @param {string} address address is the address to query balances for.
     * @param {string} denom denom is the coin denom to query balances for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.balance = function (address, denom, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).balance(address, denom, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Params queries the parameters of x/bank module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.bankParams = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).bankParams(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary CommunityPool queries the community pool coins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.communityPool = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).communityPool(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary CurrentPlan queries the current upgrade plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.currentPlan = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).currentPlan(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Delegation queries delegate info for given validator delegator pair.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.delegation = function (validatorAddr, delegatorAddr, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).delegation(validatorAddr, delegatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DelegationRewards queries the total rewards accrued by a delegation.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.delegationRewards = function (delegatorAddress, validatorAddress, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).delegationRewards(delegatorAddress, validatorAddress, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.delegationTotalRewards = function (delegatorAddress, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).delegationTotalRewards(delegatorAddress, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DelegatorDelegations queries all delegations of a given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.delegatorDelegations = function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.delegatorUnbondingDelegations = function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DelegatorValidator queries validator info for given delegator validator pair.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.delegatorValidator = function (delegatorAddr, validatorAddr, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).delegatorValidator(delegatorAddr, validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DelegatorValidators queries the validators of a delegator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.delegatorValidators = function (delegatorAddress, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).delegatorValidators(delegatorAddress, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.delegatorWithdrawAddress = function (delegatorAddress, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).delegatorWithdrawAddress(delegatorAddress, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DenomsMetadata queries the client metadata of a given coin denomination.
     * @param {string} denom denom is the coin denom to query the metadata for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.denomMetadata = function (denom, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).denomMetadata(denom, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DenomOwners queries for all account addresses that own a particular token denomination.
     * @param {string} denom denom defines the coin denomination to query all account holders for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.denomOwners = function (denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.denomsMetadata = function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Deposit queries single deposit information based proposalID, depositAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} depositor depositor defines the deposit addresses from the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.deposit = function (proposalId, depositor, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).deposit(proposalId, depositor, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Deposits queries all deposits of a single proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.deposits = function (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Params queries params of the distribution module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.distributionParams = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).distributionParams(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Evidence queries evidence based on evidence hash.
     * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.evidence = function (evidenceHash, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).evidence(evidenceHash, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Params queries all parameters of the gov module.
     * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.govParams = function (paramsType, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).govParams(paramsType, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Returns list of `Authorization`, granted to the grantee by the granter.
     * @param {string} [granter]
     * @param {string} [grantee]
     * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.grants = function (granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary HistoricalInfo queries the historical info for given height.
     * @param {string} height height defines at which height to query the historical info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.historicalInfo = function (height, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).historicalInfo(height, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Inflation returns the current minting inflation value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.inflation = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).inflation(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Params returns the total set of minting parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.mintParams = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).mintParams(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary ModuleVersions queries the list of module versions from state.
     * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.moduleVersions = function (moduleName, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).moduleVersions(moduleName, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Params queries a specific parameter of a module, given its subspace and key.
     * @param {string} [subspace] subspace defines the module to query the parameter for.
     * @param {string} [key] key defines the key of the parameter in the subspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.params = function (subspace, key, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).params(subspace, key, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Pool queries the pool info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.pool = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).pool(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Proposal queries proposal details based on ProposalID.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.proposal = function (proposalId, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).proposal(proposalId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Proposals queries all proposals based on given status.
     * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @param {string} [voter] voter defines the voter address for the proposals.
     * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.proposals = function (proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Redelegations queries redelegations of given address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
     * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.redelegations = function (delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary SigningInfo queries the signing info of given cons address
     * @param {string} consAddress cons_address is the address to query signing info of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.signingInfo = function (consAddress, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).signingInfo(consAddress, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary SigningInfos queries signing info of all validators
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.signingInfos = function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Params queries the parameters of slashing module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.slashingParams = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).slashingParams(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary DelegatorValidators queries all validators info for given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.stakingDelegatorValidators = function (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Parameters queries the staking parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.stakingParams = function (options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).stakingParams(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary SupplyOf queries the supply of a single coin.
     * @param {string} denom denom is the coin denom to query balances for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.supplyOf = function (denom, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).supplyOf(denom, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary TallyResult queries the tally of a proposal vote.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.tallyResult = function (proposalId, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).tallyResult(proposalId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary TotalSupply queries the total supply of all coins.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.totalSupply = function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.unbondingDelegation = function (validatorAddr, delegatorAddr, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).unbondingDelegation(validatorAddr, delegatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
     * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.upgradedConsensusState = function (lastHeight, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).upgradedConsensusState(lastHeight, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Validator queries validator info for given validator address.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.validator = function (validatorAddr, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).validator(validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary ValidatorCommission queries accumulated commission for a validator.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.validatorCommission = function (validatorAddress, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).validatorCommission(validatorAddress, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary ValidatorDelegations queries delegate info for given validator.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.validatorDelegations = function (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary ValidatorOutstandingRewards queries rewards of a validator address.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.validatorOutstandingRewards = function (validatorAddress, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).validatorOutstandingRewards(validatorAddress, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary ValidatorSlashes queries slash events of a validator.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
     * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.validatorSlashes = function (validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.validatorUnbondingDelegations = function (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Validators queries all validators that match the given status.
     * @param {string} [status] status enables to query for validators matching a given status.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.validators = function (status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Vote queries voted information based on proposalID, voterAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} voter voter defines the oter address for the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.vote = function (proposalId, voter, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).vote(proposalId, voter, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Votes queries votes of a given proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    QueryApi.prototype.votes = function (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.QueryApiFp)(this.configuration).votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return QueryApi;
}(base_1.BaseAPI));
exports.QueryApi = QueryApi;
/**
 * ServiceApi - axios parameter creator
 * @export
 */
var ServiceApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx: function (body, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'body' is not null or undefined
                    if (body === null || body === undefined) {
                        throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling broadcastTx.');
                    }
                    localVarPath = "/cosmos/tx/v1beta1/txs";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof body !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(body !== undefined ? body : {})
                        : (body || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight: function (height, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'height' is not null or undefined
                    if (height === null || height === undefined) {
                        throw new base_1.RequiredError('height', 'Required parameter height was null or undefined when calling getBlockByHeight.');
                    }
                    localVarPath = "/cosmos/base/tendermint/v1beta1/blocks/{height}"
                        .replace("{" + "height" + "}", encodeURIComponent(String(height)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/base/tendermint/v1beta1/blocks/latest";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/base/tendermint/v1beta1/validatorsets/latest";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/base/tendermint/v1beta1/node_info";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/base/tendermint/v1beta1/syncing";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: function (hash, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'hash' is not null or undefined
                    if (hash === null || hash === undefined) {
                        throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getTx.');
                    }
                    localVarPath = "/cosmos/tx/v1beta1/txs/{hash}"
                        .replace("{" + "hash" + "}", encodeURIComponent(String(hash)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent: function (events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/cosmos/tx/v1beta1/txs";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (events) {
                        localVarQueryParameter['events'] = events;
                    }
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    if (orderBy !== undefined) {
                        localVarQueryParameter['order_by'] = orderBy;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight: function (height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'height' is not null or undefined
                    if (height === null || height === undefined) {
                        throw new base_1.RequiredError('height', 'Required parameter height was null or undefined when calling getValidatorSetByHeight.');
                    }
                    localVarPath = "/cosmos/base/tendermint/v1beta1/validatorsets/{height}"
                        .replace("{" + "height" + "}", encodeURIComponent(String(height)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (paginationKey !== undefined) {
                        localVarQueryParameter['pagination.key'] = paginationKey;
                    }
                    if (paginationOffset !== undefined) {
                        localVarQueryParameter['pagination.offset'] = paginationOffset;
                    }
                    if (paginationLimit !== undefined) {
                        localVarQueryParameter['pagination.limit'] = paginationLimit;
                    }
                    if (paginationCountTotal !== undefined) {
                        localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
                    }
                    if (paginationReverse !== undefined) {
                        localVarQueryParameter['pagination.reverse'] = paginationReverse;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate: function (body, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'body' is not null or undefined
                    if (body === null || body === undefined) {
                        throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling simulate.');
                    }
                    localVarPath = "/cosmos/tx/v1beta1/simulate";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof body !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(body !== undefined ? body : {})
                        : (body || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.ServiceApiAxiosParamCreator = ServiceApiAxiosParamCreator;
/**
 * ServiceApi - functional programming interface
 * @export
 */
var ServiceApiFp = function (configuration) {
    return {
        /**
         *
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx: function (body, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).broadcastTx(body, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight: function (height, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).getBlockByHeight(height, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).getLatestBlock(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).getNodeInfo(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).getSyncing(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: function (hash, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).getTx(hash, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent: function (events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight: function (height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate: function (body, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.ServiceApiAxiosParamCreator)(configuration).simulate(body, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.ServiceApiFp = ServiceApiFp;
/**
 * ServiceApi - factory interface
 * @export
 */
var ServiceApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx: function (body, options) {
            return (0, exports.ServiceApiFp)(configuration).broadcastTx(body, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight: function (height, options) {
            return (0, exports.ServiceApiFp)(configuration).getBlockByHeight(height, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock: function (options) {
            return (0, exports.ServiceApiFp)(configuration).getLatestBlock(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet: function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.ServiceApiFp)(configuration).getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: function (options) {
            return (0, exports.ServiceApiFp)(configuration).getNodeInfo(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing: function (options) {
            return (0, exports.ServiceApiFp)(configuration).getSyncing(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: function (hash, options) {
            return (0, exports.ServiceApiFp)(configuration).getTx(hash, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent: function (events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options) {
            return (0, exports.ServiceApiFp)(configuration).getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight: function (height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return (0, exports.ServiceApiFp)(configuration).getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate: function (body, options) {
            return (0, exports.ServiceApiFp)(configuration).simulate(body, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ServiceApiFactory = ServiceApiFactory;
/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
var ServiceApi = /** @class */ (function (_super) {
    __extends(ServiceApi, _super);
    function ServiceApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary BroadcastTx broadcast transaction.
     * @param {InlineObject16} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.broadcastTx = function (body, options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).broadcastTx(body, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary GetBlockByHeight queries block for given height.
     * @param {string} height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.getBlockByHeight = function (height, options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).getBlockByHeight(height, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary GetLatestBlock returns the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.getLatestBlock = function (options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).getLatestBlock(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary GetLatestValidatorSet queries latest validator-set.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.getLatestValidatorSet = function (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary GetNodeInfo queries the current node info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.getNodeInfo = function (options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).getNodeInfo(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary GetSyncing queries node syncing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.getSyncing = function (options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).getSyncing(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary GetTx fetches a tx by hash.
     * @param {string} hash hash is the tx hash to query, encoded as a hex string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.getTx = function (hash, options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).getTx(hash, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary GetTxsEvent fetches txs by event.
     * @param {Array<string>} [events] events is the list of transaction event type.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.getTxsEvent = function (events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary GetValidatorSetByHeight queries validator-set at a given height.
     * @param {string} height
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.getValidatorSetByHeight = function (height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Simulate simulates executing a transaction for estimating gas usage.
     * @param {CosmosTxV1beta1SimulateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    ServiceApi.prototype.simulate = function (body, options) {
        var _this = this;
        return (0, exports.ServiceApiFp)(this.configuration).simulate(body, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ServiceApi;
}(base_1.BaseAPI));
exports.ServiceApi = ServiceApi;
/**
 * SlashingApi - axios parameter creator
 * @export
 */
var SlashingApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParametersGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/slashing/parameters";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingSigningInfosGet: function (page, limit, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'page' is not null or undefined
                    if (page === null || page === undefined) {
                        throw new base_1.RequiredError('page', 'Required parameter page was null or undefined when calling slashingSigningInfosGet.');
                    }
                    // verify required parameter 'limit' is not null or undefined
                    if (limit === null || limit === undefined) {
                        throw new base_1.RequiredError('limit', 'Required parameter limit was null or undefined when calling slashingSigningInfosGet.');
                    }
                    localVarPath = "/slashing/signing_infos";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (page !== undefined) {
                        localVarQueryParameter['page'] = page;
                    }
                    if (limit !== undefined) {
                        localVarQueryParameter['limit'] = limit;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingValidatorsValidatorAddrUnjailPost: function (validatorAddr, unjailBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling slashingValidatorsValidatorAddrUnjailPost.');
                    }
                    // verify required parameter 'unjailBody' is not null or undefined
                    if (unjailBody === null || unjailBody === undefined) {
                        throw new base_1.RequiredError('unjailBody', 'Required parameter unjailBody was null or undefined when calling slashingValidatorsValidatorAddrUnjailPost.');
                    }
                    localVarPath = "/slashing/validators/{validatorAddr}/unjail"
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof unjailBody !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(unjailBody !== undefined ? unjailBody : {})
                        : (unjailBody || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.SlashingApiAxiosParamCreator = SlashingApiAxiosParamCreator;
/**
 * SlashingApi - functional programming interface
 * @export
 */
var SlashingApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParametersGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.SlashingApiAxiosParamCreator)(configuration).slashingParametersGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingSigningInfosGet: function (page, limit, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.SlashingApiAxiosParamCreator)(configuration).slashingSigningInfosGet(page, limit, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingValidatorsValidatorAddrUnjailPost: function (validatorAddr, unjailBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.SlashingApiAxiosParamCreator)(configuration).slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.SlashingApiFp = SlashingApiFp;
/**
 * SlashingApi - factory interface
 * @export
 */
var SlashingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParametersGet: function (options) {
            return (0, exports.SlashingApiFp)(configuration).slashingParametersGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingSigningInfosGet: function (page, limit, options) {
            return (0, exports.SlashingApiFp)(configuration).slashingSigningInfosGet(page, limit, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingValidatorsValidatorAddrUnjailPost: function (validatorAddr, unjailBody, options) {
            return (0, exports.SlashingApiFp)(configuration).slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SlashingApiFactory = SlashingApiFactory;
/**
 * SlashingApi - object-oriented interface
 * @export
 * @class SlashingApi
 * @extends {BaseAPI}
 */
var SlashingApi = /** @class */ (function (_super) {
    __extends(SlashingApi, _super);
    function SlashingApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get the current slashing parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    SlashingApi.prototype.slashingParametersGet = function (options) {
        var _this = this;
        return (0, exports.SlashingApiFp)(this.configuration).slashingParametersGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get sign info of all validators
     * @summary Get sign info of given all validators
     * @param {number} page Page number
     * @param {number} limit Maximum number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    SlashingApi.prototype.slashingSigningInfosGet = function (page, limit, options) {
        var _this = this;
        return (0, exports.SlashingApiFp)(this.configuration).slashingSigningInfosGet(page, limit, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Send transaction to unjail a jailed validator
     * @summary Unjail a jailed validator
     * @param {string} validatorAddr Bech32 validator address
     * @param {InlineObject7} unjailBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    SlashingApi.prototype.slashingValidatorsValidatorAddrUnjailPost = function (validatorAddr, unjailBody, options) {
        var _this = this;
        return (0, exports.SlashingApiFp)(this.configuration).slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SlashingApi;
}(base_1.BaseAPI));
exports.SlashingApi = SlashingApi;
/**
 * StakingApi - axios parameter creator
 * @export
 */
var StakingApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsGet: function (delegatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsGet.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/delegations"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsPost: function (delegatorAddr, delegation, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsPost.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/delegations"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof delegation !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(delegation !== undefined ? delegation : {})
                        : (delegation || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet.');
                    }
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/delegations/{validatorAddr}"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)))
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrRedelegationsPost: function (delegatorAddr, delegation, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrRedelegationsPost.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/redelegations"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof delegation !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(delegation !== undefined ? delegation : {})
                        : (delegation || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsGet: function (delegatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsGet.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/unbonding_delegations"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsPost: function (delegatorAddr, delegation, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsPost.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/unbonding_delegations"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof delegation !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(delegation !== undefined ? delegation : {})
                        : (delegation || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet.');
                    }
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/unbonding_delegations/{validatorAddr}"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)))
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsGet: function (delegatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsGet.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/validators"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'delegatorAddr' is not null or undefined
                    if (delegatorAddr === null || delegatorAddr === undefined) {
                        throw new base_1.RequiredError('delegatorAddr', 'Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet.');
                    }
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet.');
                    }
                    localVarPath = "/staking/delegators/{delegatorAddr}/validators/{validatorAddr}"
                        .replace("{" + "delegatorAddr" + "}", encodeURIComponent(String(delegatorAddr)))
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParametersGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/parameters";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingPoolGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/pool";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingRedelegationsGet: function (delegator, validatorFrom, validatorTo, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/redelegations";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (delegator !== undefined) {
                        localVarQueryParameter['delegator'] = delegator;
                    }
                    if (validatorFrom !== undefined) {
                        localVarQueryParameter['validator_from'] = validatorFrom;
                    }
                    if (validatorTo !== undefined) {
                        localVarQueryParameter['validator_to'] = validatorTo;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsGet: function (status, page, limit, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/validators";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (status !== undefined) {
                        localVarQueryParameter['status'] = status;
                    }
                    if (page !== undefined) {
                        localVarQueryParameter['page'] = page;
                    }
                    if (limit !== undefined) {
                        localVarQueryParameter['limit'] = limit;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrDelegationsGet: function (validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrDelegationsGet.');
                    }
                    localVarPath = "/staking/validators/{validatorAddr}/delegations"
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrGet: function (validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrGet.');
                    }
                    localVarPath = "/staking/validators/{validatorAddr}"
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrUnbondingDelegationsGet: function (validatorAddr, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'validatorAddr' is not null or undefined
                    if (validatorAddr === null || validatorAddr === undefined) {
                        throw new base_1.RequiredError('validatorAddr', 'Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrUnbondingDelegationsGet.');
                    }
                    localVarPath = "/staking/validators/{validatorAddr}/unbonding_delegations"
                        .replace("{" + "validatorAddr" + "}", encodeURIComponent(String(validatorAddr)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.StakingApiAxiosParamCreator = StakingApiAxiosParamCreator;
/**
 * StakingApi - functional programming interface
 * @export
 */
var StakingApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsGet: function (delegatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsPost: function (delegatorAddr, delegation, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrRedelegationsPost: function (delegatorAddr, delegation, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsGet: function (delegatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsPost: function (delegatorAddr, delegation, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsGet: function (delegatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParametersGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingParametersGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingPoolGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingPoolGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingRedelegationsGet: function (delegator, validatorFrom, validatorTo, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsGet: function (status, page, limit, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingValidatorsGet(status, page, limit, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrDelegationsGet: function (validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrGet: function (validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingValidatorsValidatorAddrGet(validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrUnbondingDelegationsGet: function (validatorAddr, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.StakingApiAxiosParamCreator)(configuration).stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.StakingApiFp = StakingApiFp;
/**
 * StakingApi - factory interface
 * @export
 */
var StakingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsGet: function (delegatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsPost: function (delegatorAddr, delegation, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrRedelegationsPost: function (delegatorAddr, delegation, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsGet: function (delegatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsPost: function (delegatorAddr, delegation, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsGet: function (delegatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet: function (delegatorAddr, validatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParametersGet: function (options) {
            return (0, exports.StakingApiFp)(configuration).stakingParametersGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingPoolGet: function (options) {
            return (0, exports.StakingApiFp)(configuration).stakingPoolGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingRedelegationsGet: function (delegator, validatorFrom, validatorTo, options) {
            return (0, exports.StakingApiFp)(configuration).stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsGet: function (status, page, limit, options) {
            return (0, exports.StakingApiFp)(configuration).stakingValidatorsGet(status, page, limit, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrDelegationsGet: function (validatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrGet: function (validatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingValidatorsValidatorAddrGet(validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrUnbondingDelegationsGet: function (validatorAddr, options) {
            return (0, exports.StakingApiFp)(configuration).stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.StakingApiFactory = StakingApiFactory;
/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
var StakingApi = /** @class */ (function (_super) {
    __extends(StakingApi, _super);
    function StakingApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get all delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrDelegationsGet = function (delegatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Submit delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject4} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrDelegationsPost = function (delegatorAddr, delegation, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Query the current delegation between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet = function (delegatorAddr, validatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Submit a redelegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject6} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrRedelegationsPost = function (delegatorAddr, delegation, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get all unbonding delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrUnbondingDelegationsGet = function (delegatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Submit an unbonding delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject5} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrUnbondingDelegationsPost = function (delegatorAddr, delegation, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Query all unbonding delegations between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet = function (delegatorAddr, validatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Query all validators that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrValidatorsGet = function (delegatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Query a validator that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 ValAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet = function (delegatorAddr, validatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get the current staking parameter values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingParametersGet = function (options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingParametersGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get the current state of the staking pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingPoolGet = function (options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingPoolGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get all redelegations (filter by query params)
     * @param {string} [delegator] Bech32 AccAddress of Delegator
     * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
     * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingRedelegationsGet = function (delegator, validatorFrom, validatorTo, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get all validator candidates. By default it returns only the bonded validators.
     * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
     * @param {number} [page] The page number.
     * @param {number} [limit] The maximum number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingValidatorsGet = function (status, page, limit, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingValidatorsGet(status, page, limit, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get all delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingValidatorsValidatorAddrDelegationsGet = function (validatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Query the information from a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingValidatorsValidatorAddrGet = function (validatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingValidatorsValidatorAddrGet(validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get all unbonding delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stakingValidatorsValidatorAddrUnbondingDelegationsGet = function (validatorAddr, options) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return StakingApi;
}(base_1.BaseAPI));
exports.StakingApi = StakingApi;
/**
 * TendermintRPCApi - axios parameter creator
 * @export
 */
var TendermintRPCApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksHeightGet: function (height, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'height' is not null or undefined
                    if (height === null || height === undefined) {
                        throw new base_1.RequiredError('height', 'Required parameter height was null or undefined when calling blocksHeightGet.');
                    }
                    localVarPath = "/blocks/{height}"
                        .replace("{" + "height" + "}", encodeURIComponent(String(height)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksLatestGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/blocks/latest";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/syncing";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsHeightGet: function (height, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'height' is not null or undefined
                    if (height === null || height === undefined) {
                        throw new base_1.RequiredError('height', 'Required parameter height was null or undefined when calling validatorsetsHeightGet.');
                    }
                    localVarPath = "/validatorsets/{height}"
                        .replace("{" + "height" + "}", encodeURIComponent(String(height)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         *
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsLatestGet: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/validatorsets/latest";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.TendermintRPCApiAxiosParamCreator = TendermintRPCApiAxiosParamCreator;
/**
 * TendermintRPCApi - functional programming interface
 * @export
 */
var TendermintRPCApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksHeightGet: function (height, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TendermintRPCApiAxiosParamCreator)(configuration).blocksHeightGet(height, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksLatestGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TendermintRPCApiAxiosParamCreator)(configuration).blocksLatestGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TendermintRPCApiAxiosParamCreator)(configuration).syncingGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsHeightGet: function (height, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TendermintRPCApiAxiosParamCreator)(configuration).validatorsetsHeightGet(height, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsLatestGet: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TendermintRPCApiAxiosParamCreator)(configuration).validatorsetsLatestGet(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.TendermintRPCApiFp = TendermintRPCApiFp;
/**
 * TendermintRPCApi - factory interface
 * @export
 */
var TendermintRPCApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksHeightGet: function (height, options) {
            return (0, exports.TendermintRPCApiFp)(configuration).blocksHeightGet(height, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksLatestGet: function (options) {
            return (0, exports.TendermintRPCApiFp)(configuration).blocksLatestGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingGet: function (options) {
            return (0, exports.TendermintRPCApiFp)(configuration).syncingGet(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsHeightGet: function (height, options) {
            return (0, exports.TendermintRPCApiFp)(configuration).validatorsetsHeightGet(height, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsLatestGet: function (options) {
            return (0, exports.TendermintRPCApiFp)(configuration).validatorsetsLatestGet(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.TendermintRPCApiFactory = TendermintRPCApiFactory;
/**
 * TendermintRPCApi - object-oriented interface
 * @export
 * @class TendermintRPCApi
 * @extends {BaseAPI}
 */
var TendermintRPCApi = /** @class */ (function (_super) {
    __extends(TendermintRPCApi, _super);
    function TendermintRPCApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get a block at a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    TendermintRPCApi.prototype.blocksHeightGet = function (height, options) {
        var _this = this;
        return (0, exports.TendermintRPCApiFp)(this.configuration).blocksHeightGet(height, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get the latest block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    TendermintRPCApi.prototype.blocksLatestGet = function (options) {
        var _this = this;
        return (0, exports.TendermintRPCApiFp)(this.configuration).blocksLatestGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get if the node is currently syning with other nodes
     * @summary Syncing state of node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    TendermintRPCApi.prototype.syncingGet = function (options) {
        var _this = this;
        return (0, exports.TendermintRPCApiFp)(this.configuration).syncingGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get a validator set a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    TendermintRPCApi.prototype.validatorsetsHeightGet = function (height, options) {
        var _this = this;
        return (0, exports.TendermintRPCApiFp)(this.configuration).validatorsetsHeightGet(height, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get the latest validator set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    TendermintRPCApi.prototype.validatorsetsLatestGet = function (options) {
        var _this = this;
        return (0, exports.TendermintRPCApiFp)(this.configuration).validatorsetsLatestGet(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return TendermintRPCApi;
}(base_1.BaseAPI));
exports.TendermintRPCApi = TendermintRPCApi;
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
var TransactionsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsDecodePost: function (tx, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'tx' is not null or undefined
                    if (tx === null || tx === undefined) {
                        throw new base_1.RequiredError('tx', 'Required parameter tx was null or undefined when calling txsDecodePost.');
                    }
                    localVarPath = "/txs/decode";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof tx !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(tx !== undefined ? tx : {})
                        : (tx || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsEncodePost: function (tx, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'tx' is not null or undefined
                    if (tx === null || tx === undefined) {
                        throw new base_1.RequiredError('tx', 'Required parameter tx was null or undefined when calling txsEncodePost.');
                    }
                    localVarPath = "/txs/encode";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof tx !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(tx !== undefined ? tx : {})
                        : (tx || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsGet: function (messageAction, messageSender, page, limit, txMinheight, txMaxheight, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/txs";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (messageAction !== undefined) {
                        localVarQueryParameter['message.action'] = messageAction;
                    }
                    if (messageSender !== undefined) {
                        localVarQueryParameter['message.sender'] = messageSender;
                    }
                    if (page !== undefined) {
                        localVarQueryParameter['page'] = page;
                    }
                    if (limit !== undefined) {
                        localVarQueryParameter['limit'] = limit;
                    }
                    if (txMinheight !== undefined) {
                        localVarQueryParameter['tx.minheight'] = txMinheight;
                    }
                    if (txMaxheight !== undefined) {
                        localVarQueryParameter['tx.maxheight'] = txMaxheight;
                    }
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsHashGet: function (hash, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'hash' is not null or undefined
                    if (hash === null || hash === undefined) {
                        throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling txsHashGet.');
                    }
                    localVarPath = "/txs/{hash}"
                        .replace("{" + "hash" + "}", encodeURIComponent(String(hash)));
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsPost: function (txBroadcast, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, queryParameters, key, key, headersFromBaseOptions, nonString, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'txBroadcast' is not null or undefined
                    if (txBroadcast === null || txBroadcast === undefined) {
                        throw new base_1.RequiredError('txBroadcast', 'Required parameter txBroadcast was null or undefined when calling txsPost.');
                    }
                    localVarPath = "/txs";
                    localVarUrlObj = new URL(localVarPath, 'https://example.com');
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    queryParameters = new URLSearchParams(localVarUrlObj.search);
                    for (key in localVarQueryParameter) {
                        queryParameters.set(key, localVarQueryParameter[key]);
                    }
                    for (key in options.query) {
                        queryParameters.set(key, options.query[key]);
                    }
                    localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    nonString = typeof txBroadcast !== 'string';
                    needsSerialization = nonString && configuration && configuration.isJsonMime
                        ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                        : nonString;
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(txBroadcast !== undefined ? txBroadcast : {})
                        : (txBroadcast || "");
                    return [2 /*return*/, {
                            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.TransactionsApiAxiosParamCreator = TransactionsApiAxiosParamCreator;
/**
 * TransactionsApi - functional programming interface
 * @export
 */
var TransactionsApiFp = function (configuration) {
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsDecodePost: function (tx, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TransactionsApiAxiosParamCreator)(configuration).txsDecodePost(tx, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsEncodePost: function (tx, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TransactionsApiAxiosParamCreator)(configuration).txsEncodePost(tx, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsGet: function (messageAction, messageSender, page, limit, txMinheight, txMaxheight, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TransactionsApiAxiosParamCreator)(configuration).txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsHashGet: function (hash, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TransactionsApiAxiosParamCreator)(configuration).txsHashGet(hash, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsPost: function (txBroadcast, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, exports.TransactionsApiAxiosParamCreator)(configuration).txsPost(txBroadcast, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
exports.TransactionsApiFp = TransactionsApiFp;
/**
 * TransactionsApi - factory interface
 * @export
 */
var TransactionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsDecodePost: function (tx, options) {
            return (0, exports.TransactionsApiFp)(configuration).txsDecodePost(tx, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsEncodePost: function (tx, options) {
            return (0, exports.TransactionsApiFp)(configuration).txsEncodePost(tx, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsGet: function (messageAction, messageSender, page, limit, txMinheight, txMaxheight, options) {
            return (0, exports.TransactionsApiFp)(configuration).txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsHashGet: function (hash, options) {
            return (0, exports.TransactionsApiFp)(configuration).txsHashGet(hash, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsPost: function (txBroadcast, options) {
            return (0, exports.TransactionsApiFp)(configuration).txsPost(txBroadcast, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.TransactionsApiFactory = TransactionsApiFactory;
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
var TransactionsApi = /** @class */ (function (_super) {
    __extends(TransactionsApi, _super);
    function TransactionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
     * @summary Decode a transaction from the Amino wire format
     * @param {InlineObject2} tx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    TransactionsApi.prototype.txsDecodePost = function (tx, options) {
        var _this = this;
        return (0, exports.TransactionsApiFp)(this.configuration).txsDecodePost(tx, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
     * @summary Encode a transaction to the Amino wire format
     * @param {InlineObject1} tx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    TransactionsApi.prototype.txsEncodePost = function (tx, options) {
        var _this = this;
        return (0, exports.TransactionsApiFp)(this.configuration).txsEncodePost(tx, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Search transactions by events.
     * @summary Search transactions
     * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
     * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
     * @param {number} [page] Page number
     * @param {number} [limit] Maximum number of items per page
     * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
     * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    TransactionsApi.prototype.txsGet = function (messageAction, messageSender, page, limit, txMinheight, txMaxheight, options) {
        var _this = this;
        return (0, exports.TransactionsApiFp)(this.configuration).txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve a transaction using its hash.
     * @summary Get a Tx by hash
     * @param {string} hash Tx hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    TransactionsApi.prototype.txsHashGet = function (hash, options) {
        var _this = this;
        return (0, exports.TransactionsApiFp)(this.configuration).txsHashGet(hash, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Broadcast a signed tx to a full node
     * @summary Broadcast a signed tx
     * @param {InlineObject} txBroadcast
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    TransactionsApi.prototype.txsPost = function (txBroadcast, options) {
        var _this = this;
        return (0, exports.TransactionsApiFp)(this.configuration).txsPost(txBroadcast, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return TransactionsApi;
}(base_1.BaseAPI));
exports.TransactionsApi = TransactionsApi;
